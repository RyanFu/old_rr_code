package com.xiaonei.commons.jade.impl.jdbcwrapper;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * 继承: BaseStatement 定制数据库查询语句。
 * 
 * @author han.liao
 * 
 * @param <E> - 内部的查询类型。
 */
public abstract class BaseStatement<E extends Statement> implements Statement {

    /** 供派生类使用 */
    protected static final Log logger = LogFactory.getLog(BaseStatement.class);

    // 内部的数据库查询语句。
    protected E statement;

    protected int fetchDirection, fetchSize;

    protected int maxFieldSize, maxRows;

    protected int queryTimeout = 0;

    protected String cursorName;

    protected Boolean escapeProcessing, poolable;

    protected boolean closed;

    @Override
    public void close() throws SQLException {

        freeStatement();

        closed = true;
    }

    @Override
    public void cancel() throws SQLException {

        if (statement != null) {
            statement.cancel();
        }
    }

    @Override
    public void addBatch(String sql) throws SQLException {

        initStatement();

        statement.addBatch(sql);
    }

    @Override
    public void clearBatch() throws SQLException {

        initStatement();

        statement.clearBatch();
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {

        initStatement();

        return statement.getWarnings();
    }

    @Override
    public void clearWarnings() throws SQLException {

        if (statement != null) {
            statement.clearWarnings();
        }
    }

    @Override
    public boolean execute(String sql) throws SQLException {

        initStatement();

        return statement.execute(sql);
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {

        initStatement();

        return statement.execute(sql, autoGeneratedKeys);
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {

        initStatement();

        return statement.execute(sql, columnIndexes);
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {

        initStatement();

        return statement.execute(sql, columnNames);
    }

    @Override
    public int[] executeBatch() throws SQLException {

        initStatement();

        return statement.executeBatch();
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {

        initStatement();

        return statement.executeQuery(sql);
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {

        initStatement();

        return statement.executeUpdate(sql);
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {

        initStatement();

        return statement.executeUpdate(sql, autoGeneratedKeys);
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {

        initStatement();

        return statement.executeUpdate(sql, columnIndexes);
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {

        initStatement();

        return statement.executeUpdate(sql, columnNames);
    }

    @Override
    public ResultSet getResultSet() throws SQLException {

        if (statement != null) {
            return statement.getResultSet();
        }

        return null;
    }

    @Override
    public boolean getMoreResults() throws SQLException {

        if (statement != null) {
            return statement.getMoreResults();
        }

        return false;
    }

    @Override
    public boolean getMoreResults(int current) throws SQLException {

        if (statement != null) {
            return statement.getMoreResults(current);
        }

        return false;
    }

    @Override
    public int getUpdateCount() throws SQLException {

        if (statement != null) {
            return statement.getUpdateCount();
        }

        return -1;
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {

        initStatement();

        return statement.getGeneratedKeys();
    }

    @Override
    public int getResultSetType() throws SQLException {

        initStatement();

        return statement.getResultSetType();
    }

    @Override
    public int getResultSetConcurrency() throws SQLException {

        initStatement();

        return statement.getResultSetConcurrency();
    }

    @Override
    public int getResultSetHoldability() throws SQLException {

        initStatement();

        return statement.getResultSetHoldability();
    }

    @Override
    public boolean isClosed() throws SQLException {

        if (statement != null) {
            return statement.isClosed();
        }

        return closed;
    }

    @Override
    public boolean isPoolable() throws SQLException {

        initStatement();

        return statement.isPoolable();
    }

    @Override
    public void setPoolable(boolean poolable) throws SQLException {

        if (statement != null) {
            statement.setPoolable(poolable);
        }

        this.poolable = Boolean.valueOf(poolable);
    }

    @Override
    public int getFetchDirection() throws SQLException {

        if (fetchDirection == 0) {
            return ResultSet.FETCH_FORWARD;
        }

        return fetchDirection;
    }

    @Override
    public void setFetchDirection(int direction) throws SQLException {

        if (statement != null) {
            statement.setFetchDirection(direction);
        }

        fetchDirection = direction;
    }

    @Override
    public int getFetchSize() throws SQLException {

        return fetchSize;
    }

    @Override
    public void setFetchSize(int rows) throws SQLException {

        if (statement != null) {
            statement.setFetchSize(rows);
        }

        fetchSize = rows;
    }

    @Override
    public int getMaxFieldSize() throws SQLException {

        return maxFieldSize;
    }

    @Override
    public void setMaxFieldSize(int max) throws SQLException {

        if (statement != null) {
            statement.setMaxFieldSize(max);
        }

        maxFieldSize = max;
    }

    @Override
    public int getMaxRows() throws SQLException {

        return maxRows;
    }

    @Override
    public void setMaxRows(int max) throws SQLException {

        if (statement != null) {
            statement.setMaxRows(max);
        }

        maxRows = max;
    }

    @Override
    public int getQueryTimeout() throws SQLException {

        return queryTimeout;
    }

    @Override
    public void setQueryTimeout(int seconds) throws SQLException {

        if (statement != null) {
            statement.setQueryTimeout(seconds);
        }

        queryTimeout = seconds;
    }

    @Override
    public void setCursorName(String name) throws SQLException {

        if (statement != null) {
            statement.setCursorName(name);
        }

        cursorName = name;
    }

    @Override
    public void setEscapeProcessing(boolean enable) throws SQLException {

        if (statement != null) {
            statement.setEscapeProcessing(enable);
        }

        this.escapeProcessing = Boolean.valueOf(enable);
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return Statement.class.equals(iface);
    }

    @Override
    public <T> T unwrap(Class<T> iface) throws SQLException {

        if (!Statement.class.equals(iface)) {
            throw new SQLException("Statement [" + getClass().getName()
                    + "] can't be unwrapped as [" + iface.getName() + "].");
        }

        return iface.cast(this);
    }

    /**
     * 实现该函数获取真实的数据库查询语句。 <br>
     * 
     * @return 真实的数据库查询语句。
     * 
     * @throws SQLException
     */
    protected abstract E createStatement() throws SQLException;

    /**
     * 如果没有就初始化数据库查询语句。
     * 
     * @throws SQLException
     */
    protected void initStatement() throws SQLException {

        if (statement == null) {

            if (closed) {
                throw new SQLException("Statement is closed.", // NL
                        "08003" /* SQLError.SQL_STATE_CONNECTION_NOT_OPEN */);
            }

            // 输出日志。
            if (logger.isDebugEnabled()) {
                logger.debug("Creating wrapped statement");
            }

            // 创建查询语句。
            statement = createStatement();

            // 初始化查询语句。
            if (fetchDirection != 0) {
                statement.setFetchDirection(fetchDirection);
            }

            if (fetchSize != 0) {
                statement.setFetchSize(fetchSize);
            }

            if (maxFieldSize != 0) {
                statement.setMaxFieldSize(maxFieldSize);
            }

            if (maxRows != 0) {
                statement.setMaxRows(maxRows);
            }

            if (queryTimeout != 0) {
                statement.setQueryTimeout(queryTimeout);
            }

            if (cursorName != null) {
                statement.setCursorName(cursorName);
            }

            if (escapeProcessing != null) {
                statement.setEscapeProcessing(escapeProcessing);
            }

            if (poolable != null) {
                statement.setPoolable(poolable);
            }
        }
    }

    /**
     * 释放现在的数据库查询语句。
     * 
     * @throws SQLException
     */
    protected void freeStatement() throws SQLException {

        if (statement != null) {

            // 输出日志。
            if (logger.isDebugEnabled()) {
                logger.debug("Closing wrapped statement");
            }

            // 关闭查询语句。
            statement.close();
            statement = null;
        }
    }
}
